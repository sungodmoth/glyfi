use std::arch::x86_64;
use std::sync::Arc;
use std::collections::HashMap;
use crate::core::report_user_error;
use crate::file::download_pfp;
use crate::scheduling::schedule_loop;
use crate::server_data::{
    AMBIGRAM_ANNOUNCEMENTS_CHANNEL_ID, AMBIGRAM_SUBMISSION_CHANNEL_ID, GLYFI_USER_ID, GLYPH_ANNOUNCEMENTS_CHANNEL_ID, GLYPH_SUBMISSION_CHANNEL_ID, SUBMIT_EMOJI_ID, VOTING_EMOJI_SEQUENCE
};
use crate::sql::{check_submission, check_user, get_current_week, get_votes, get_week_info, register_user, register_vote};
use crate::types::{AnyEmoji, Challenge, UserVoteReplyStatus, UserVoteStatusData};
use crate::{err, file, info, info_sync, sql, Res, ResT};
use chrono::{Duration, Utc};
use poise::serenity_prelude::*;
use tokio::sync::RwLock;
use tokio::time;

pub struct GlyfiEvents;

/// Execute code and notify the user if execution fails.
macro_rules! run {
    ($ctx:expr, $user:expr, $code:expr, $msg:expr) => {
        if let Err(e) = $code {
            err!("{}: {}", $msg, e);
            report_user_error(
                $ctx,
                $user,
                &format!("Sorry, an internal error occurred: {}: {}\nPlease contact @sungodmoth to file a bug report.", $msg, e)
            ).await;
            return;
        }
    }
}

/// Get the confirm emoji.
fn confirm_reaction() -> ReactionType {
    return ReactionType::Unicode("✅".into());
}

/// Helper function for interaction handler. Gets the relevant information from a button's custom_id,
/// and fetches the current week, so we get one convenient ResT with all the data that could cause errors.
async fn parse_button_data_get_current_week(custom_id: &str) -> ResT<(Challenge, i64, i64, i64)> {
    let mut iter = custom_id.chars();
    let challenge_char = iter.next().ok_or("Empty custom_id on button.".to_string())?;
    let challenge = match challenge_char { 'g' => Ok(Challenge::Glyph), 'a' => Ok(Challenge::Ambigram), _ => {
        Err(format!("Not a valid challenge name: {}", challenge_char).to_string()) } }?;
    let week_num_str = iter.by_ref().take(4).collect::<String>();
    let week_num = week_num_str.parse::<i64>()?;
    let sub_num_str = iter.skip(1).take(3).collect::<String>();
    let sub_num = sub_num_str.parse::<i64>()?;
    let current_week = get_current_week(challenge).await?;
    Ok((challenge, week_num, sub_num, current_week))
}

/// Does most of the logic of handling votes, including replying to the interaction generated by interaction_create.
/// Called once we have already determined that a button has been pressed for the correct week and so we should
/// indeed count the vote.
async fn handle_vote(i: ComponentInteraction, ctx: Context, challenge: Challenge, sub_num: i64, week_num: i64, num_subs: i64) -> Res {
    use UserVoteReplyStatus::*;
    let user_id = i.user.id;
    // initial response
    i.create_response(&ctx, CreateInteractionResponse::Acknowledge).await;
    let lock = {
        let data = ctx.data.read().await;
        data.get::<UserVoteStatusData>().ok_or("Couldn't get UserVoteStatusData.")?.clone()
    };
    loop {
        let status = {
            let vote_status_data = lock.read().await;
            vote_status_data.get(&user_id).map(|x| *x)
        };
        match status {
            Some(Responding) => {},
            _ => {
                let mut vote_status_data = lock.write().await;
                let timestamp = Utc::now().timestamp_millis() + 2000;
                vote_status_data.insert(user_id, Waiting(timestamp));
                info!("Wait time for user {} has been updated to {} by vote for sub {}:{}", user_id, timestamp, challenge.short_name(), sub_num);
                if !register_vote(challenge, week_num, user_id, sub_num).await? {
                    info!("Database operation was not successful when registering vote.")
                }
                break;
            }
        }
        tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
    }
    loop {
        let status = {
            let vote_status_data = lock.read().await;
            vote_status_data.get(&user_id).map(|x| *x)
        };
        match status {
            Some(Waiting(timestamp)) => {
                if Utc::now().timestamp_millis() > timestamp {
                    {
                        let mut vote_status_data = lock.write().await;
                        // there is a chance that while we were waiting to acquire the write lock, some other thread 
                        // got to it first and has already marked as Responding. In that case we don't want two 
                        // threads to run the actual responding logic at the same time, so we get out of here.
                        if vote_status_data.get(&user_id) == Some(&Responding) {
                            continue;
                        }
                        vote_status_data.insert(user_id, Responding);
                    }
                    info!("Responding to user votes in thread for submission number {}", sub_num);
                    // for now, we wait half a second here to make sure that any other threads are able to read
                    // that the state has been set to Responding. 
                    tokio::time::sleep(tokio::time::Duration::from_millis(500));

                    // respond with the current state of the user's votes
                    let votes : Vec<String> = get_votes(challenge, week_num, user_id, num_subs).await?.iter().map(|x| VOTING_EMOJI_SEQUENCE.get(*x as usize).map(|x| x.display_string())).flatten().collect();
                    i.create_followup(&ctx, CreateInteractionResponseFollowup::new()
                        .content(format!("Your current votes: {}", votes.join(" ")))
                        .ephemeral(true)).await;

                    {
                        let mut vote_status_data = lock.write().await;
                        vote_status_data.insert(user_id, Idle);
                    }
                    break;
                }
            },
            Some(Responding) => {
                // another thread is already responding, so we're done here
                break;
            }
            _ => { 
                // unless something goes wrong, we *should* never get here. There is no way that the status could 
                // be None (i.e. not initialised in the HashMap at all) because we already initialised it to Waiting
                // for this user_id in the current thread. For the state to have become Idle in between the first loop
                // and here, another thread must have set it to Idle, but this implies that the state was set to
                // Responding for 500ms, giving ample time for us to have read that and entered the above code path.
                return Err("handle_vote reached unexpected state.".into()); }
        }
        tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
    }           
    Ok(())
}

#[async_trait]
impl EventHandler for GlyfiEvents {
    /// Handle interactions, of which we mostly care about voting button presses.
    async fn interaction_create(&self, ctx: Context, interaction: Interaction) {
        match interaction {
            Interaction::Command(_) => { return; },
            Interaction::Component(mut i) => {
                let custom_id = i.data.custom_id.clone();
                let user_id = i.user.id;
                let (challenge, week_num, sub_num, current_week) = match parse_button_data_get_current_week(&custom_id).await { 
                    Ok(x) => x, Err(e) => { if let Err(e) = i.create_response(ctx, CreateInteractionResponse::Message(
                        CreateInteractionResponseMessage::new()
                            .content(format!("Internal error: {:?}. Contact @sungodmoth to report this error.", e))
                            .ephemeral(true))
                    ).await { err!(format!("Error reporting button interaction error to user: {e}")) }; return; 
                    }
                };
                if current_week == week_num + 1 {
                    info!("Current vote's {}th submission has been voted for by {}", sub_num + 1, user_id);
                    let num_subs = match get_week_info(week_num, challenge).await {
                        Ok(x) => x, Err(e) => { err!(format!("Error getting week data for week {}:{}: {}", challenge.short_name(), week_num, e)); return; }
                    }.num_subs;
                    // pass off execution
                    if let Err(e) = handle_vote(i, ctx, challenge, sub_num, week_num, num_subs).await {
                        err!(format!("Error handling vote: {}", e)); return; }
                } else {
                    if let Err(e) = i.create_response(ctx, CreateInteractionResponse::Message(
                        CreateInteractionResponseMessage::new()
                            .content("This vote is not currently active.")
                            .ephemeral(true))
                    ).await { err!(format!("Error reporting irrelevant button interaction to user: {e}")); return; };
                }
            },
            _ => {} 
        }
    }


    /// Check whether a user added the submit emoji.
    async fn reaction_add(&self, ctx: Context, r: Reaction) {
        
        // Helper to remove the reaction on error and return.
        macro_rules! remove_reaction {
            ($ctx:expr, $r:expr) => {
                if let Err(e) = $r.delete(&$ctx).await {
                    err!("Error removing reaction: {}", e);
                }
                return;
            };
        }
        
        let Some(member) = r.member.clone() else {
            err!("Could not retrieve member for reaction event.");
            return;
        };
        let user_id = member.user.id;
        if user_id == GLYFI_USER_ID { return; }
        
        // Ignore this outside of the submission channels.
        let challenge = match r.channel_id {
            GLYPH_SUBMISSION_CHANNEL_ID => Challenge::Glyph,
            AMBIGRAM_SUBMISSION_CHANNEL_ID => Challenge::Ambigram,
            _ => { return; },
        };
        // Ignore anything that isn’t the emoji we care about.
        if !matches!(
            r.emoji,
            ReactionType::Custom {
                id: SUBMIT_EMOJI_ID,
                ..
            }
        ) { return; };
        
        let Ok(current_week) = get_current_week(challenge).await else { return; };
        
        // TODO: check that the submission was actually posted within the current week.
        
        // we have waited as long as possible to call this function, because it makes a REST API request
        // we can get rate-limited if we make too many of these requests in a short amount of time, so we really
        // want to make sure that we care about this reaction event before we call it
        let Ok(message) = r.message(&ctx).await else { return; };

        // If someone reacted w/ this emoji to someone else’s message, remove it.
        if user_id != message.author.id {
            remove_reaction!(ctx, r);
        }

        // Check the message for attachments.
        if message.attachments.len() != 1 {
            report_user_error(&ctx, user_id, "Submissions must contain exactly one image").await;
            remove_reaction!(ctx, r);
        }

        // Safe because we just checked that that is an attachment.
        let att = message.attachments.first().unwrap();

        // Error if the attachment is not an image.
        //
        // There doesn’t really seem to be a way of checking what an attachment
        // actually is (excepting checking the mime type, which I’m not willing
        // to do), so checking whether the height exists, which it only should
        // for images, will have to do.
        if att.height.is_none() {
            report_user_error(&ctx, user_id, "Submissions must contain only images").await;
            remove_reaction!(ctx, r);
        }

        info!(
            "Adding submission {} from {} for challenge {:?}",
            message.id, user_id, challenge
        );

        run!(
            ctx,
            user_id,
            async {
                sql::register_submission(message.id, challenge, user_id, &att.url, current_week)
                    .await?;
                file::download_submission(att, message.id, challenge, current_week).await
            }
            .await,
            "Error adding submission"
        );

        match check_user(&member).await {
            Ok(false) => {
                if let Err(e) = download_pfp(&member).await {
                    err!("Error downloading user pfp: {}", e);
                }
                //the user isn't in the database
                if let Err(e) = register_user(member).await {
                    err!("Error adding user to database: {}", e);
                }
            }
            Err(e) => {
                err!("Error checking whether user is in database: {}", e)
            }
            _ => {}
        }

        // Done.
        if let Err(e) = message.react(ctx, confirm_reaction()).await {
            err!("Error reacting to submission: {}", e);
        }
    }

    async fn reaction_remove(&self, ctx: Context, r: Reaction) {
        // Check if we care about this.
        let Some(user_id) = r.user_id else { return; };
        // Ignore this outside of the submission channels.
        let challenge = match r.channel_id {
            GLYPH_SUBMISSION_CHANNEL_ID => Challenge::Glyph,
            AMBIGRAM_SUBMISSION_CHANNEL_ID => Challenge::Ambigram,
            _ => { return; },
        };
        // Ignore anything that isn’t the emoji we care about.
        if !matches!(
            r.emoji,
            ReactionType::Custom {
                id: SUBMIT_EMOJI_ID,
                ..
            }
        ) { return; };
        
        let Ok(current_week) = get_current_week(challenge).await else { return; };
        // TODO: check that the submission was actually posted within the current week.
        
        // we have waited as long as possible to call this function, because it makes a REST API request
        // we can get rate-limited if we make too many of these requests in a short amount of time, so we really
        // want to make sure that we care about this reaction event before we call it
        let Ok(message) = r.message(&ctx).await else { return; };
        
        // If the reaction that was removed is not the reaction of the
        // user that sent the message (which I guess can happen if there
            // is ever some amount of downtime on our part?) then ignore it.
            if user_id != message.author.id {
                return;
        };

        // check if we had ever registered the submission before trying to remove it
        // this will not be the case if, for instance, we just removed the user's
        // reaction for being an invalid attachment type or in the wrong channel
        match check_submission(message.id).await {
            Ok(true) => {
                info!(
                    "Removing submission {} from {} for challenge {:?}",
                    message.id, user_id, challenge
                );
                // Remove the submission.
                run!(
                    ctx,
                    user_id,
                    async {
                        sql::deregister_submission(message.id, challenge, current_week).await?;
                        file::delete_submission(message.id, challenge, current_week).await
                    }
                    .await,
                    "Error removing submission"
                );
            }
            Err(e) => {
                err!("Error checking whether submission exists: {}", e);
            }
            _ => {}
        }

        // Remove our confirmation reaction. This is allowed to fail in case
        // it was already removed somehow.
        let me = ctx.cache.current_user().id;
        let _ = message
            .delete_reaction(ctx, Some(me), confirm_reaction())
            .await;
    }

    async fn guild_member_update(
        &self,
        _ctx: Context,
        old_if_available: Option<Member>,
        new: Option<Member>,
        _g: GuildMemberUpdateEvent,
    ) {
        if let (Some(old_member), Some(new_member)) = (old_if_available, new) {
            match check_user(&new_member).await {
                Ok(true) => {
                    if old_member.face() != new_member.face() {
                        if let Err(e) = download_pfp(&new_member).await {
                            err!("Error downloading pfp: {}", e);
                        }
                    }
                }
                Err(e) => {
                    err!("Error checking whether user already exists: {}", e);
                }
                _ => {}
            }
        }
    }

    async fn ready(&self, ctx: Context, ready: Ready) {
        info_sync!("Glyfi running with id {}", ready.user.id);
        {
            let mut data = ctx.data.write().await;
            data.insert::<UserVoteStatusData>(Arc::new(RwLock::new(HashMap::new())));
        }
        //approach shamelessly copied from https://github.com/serenity-rs/serenity/blob/current/examples/e13_parallel_loops
        let ctx = Arc::new(ctx);
        let clone = Arc::clone(&ctx);
        tokio::spawn(async move {
            loop {
                if let Err(e) = schedule_loop(&clone).await {
                    err!("Error in schedule loop: {}", e)
                };
                time::sleep(time::Duration::from_secs(10)).await
        }});
    }
}
